// Compile: java -jar libs/java-cup-11b.jar parser.cup

package parser;
import java.util.List;
import java.util.LinkedList;
import parser.symbols.*;
import parser.symbols.statements.*;
import parser.symbols.expressions.*;
import parser.symbols.declarations.*;
import parser.symbols.types.*;
import parser.symbols.expressions.literals.*;
import parser.symbols.statements.assignment.*;
import parser.symbols.statements.conditional.*;
import parser.symbols.statements.io.*;
import parser.symbols.statements.loop.*;
import parser.symbols.declarations.cva.ArrayDeclaration;
import parser.symbols.declarations.cva.CVADeclaration;
import parser.symbols.declarations.cva.PrimitiveDeclaration;
import parser.symbols.declarations.subprogram.FunctionDeclaration;
import parser.symbols.declarations.subprogram.MainDeclaration;
import parser.symbols.declarations.subprogram.ProcedureDeclaration;
import parser.symbols.declarations.subprogram.SubprogramDeclaration;

class Parser;

terminal                                CONST, VAR, ARRAY, FUNCTION, PROCEDURE, MAIN, RETURN, WHILE, IF, ELSE;
terminal                                L_PAR, R_PAR, L_BOX, R_BOX, L_BRK, R_BRK, COMMA, EOL;
terminal                                READ, PRINT;
terminal                                EQUALS;
terminal                                ADD, SUB, MUL, DIV, MOD;
terminal                                AND, OR, NOT;
terminal    RelationalOperatorType      REL;
terminal    PrimitiveType               PRIM_TYPE;
terminal    String                      IDENT;

// Constants
terminal      Integer   INT_LIT;
terminal      Boolean   BOOL_LIT;
terminal      String    STR_LIT; 

non terminal  Program                       PROGRAM;

// Declarations
non terminal  SymbolList<Declaration>       DECL_LIST;
non terminal  Declaration                   DECL;
non terminal  CVADeclaration                CVA_DECL;
non terminal  PrimitiveDeclaration          PRIM_DECL;
non terminal  DeclarationMode               DECL_MODE;
non terminal  ArrayDeclaration              ARR_DECL;
non terminal  SubprogramDeclaration         SUBPRG_DECL;
non terminal  FunctionDeclaration           FUNC_DECL;
non terminal  ProcedureDeclaration          PROC_DECL;
non terminal  MainDeclaration               MAIN_DECL;

non terminal  Type                          TYPE;

non terminal  SymbolList<Argument>          ARG_TAIL;
non terminal  SymbolList<Argument>          ARG_LIST;
non terminal  Argument                      ARG;

non terminal  ArrayDimensions               ARR_DIM;
non terminal  ArrayIndexes                  ARR_INDEX;

// Statements
non terminal  SymbolList<Statement>         STMT_LIST;
non terminal  Statement                     STMT;
non terminal  Assignment                    ASGN;
non terminal  Read                          READ_STMT;
non terminal  Print                         PRINT_STMT;
non terminal  Loop                          LOOP;
non terminal  If                            IF_STMT;
non terminal  Call                          CALL;
non terminal  Return                        RETURN_STMT;

// Expressions
non terminal  List<Expression>              EXPR_LIST;
non terminal  Expression                    EXPR;
non terminal                                LIT_TAIL;
non terminal  List<Literal>                 LIT_LIST;
non terminal  Literal                       LIT;
non terminal  /*ArrayLiteral*/              ARR_LIT;

// Operators
non terminal  /*ArithmeticOperator*/        ARITH_OP;
non terminal  /*BinaryOperator*/            BIN_OP;

precedence left                             OR;
precedence left                             AND;
precedence left                             REL;
precedence left                             ADD, SUB;
precedence left                             MUL, DIV, MOD;

start with PROGRAM;

PROGRAM     ::= DECL_LIST:l MAIN_DECL:m                             {: RESULT = new Program(l, m); :}
              ;

DECL        ::= CVA_DECL:d                                          {: RESULT = d; :}
              | SUBPRG_DECL:d                                       {: RESULT = d; :}
              ;

DECL_LIST   ::= DECL:d DECL_LIST: l                                 {: RESULT = new SymbolList<>(l, d); :}
              |                                                     {: RESULT = new SymbolList<>(); :}
              ;

CVA_DECL    ::= PRIM_DECL:d                                         {: RESULT = d; :}                                           
              | ARR_DECL:d                                          {: RESULT = d; :}
              ;

PRIM_DECL   ::= DECL_MODE:m PRIM_TYPE:pt IDENT:i EOL                {: RESULT = new PrimitiveDeclaration(m, pt, i); :}   
              ;

ARR_DECL    ::= DECL_MODE:m ARRAY PRIM_TYPE:p ARR_DIM:d IDENT:i EOL {: RESULT = new ArrayDeclaration(m, p, d, i); :}
              ;

DECL_MODE   ::= CONST                                               {: RESULT = DeclarationMode.getConstant(); :}
              | VAR                                                 {: RESULT = DeclarationMode.getVariable(); :}
              ;

TYPE        ::= PRIM_TYPE:pt                                        {: RESULT = new Type(pt); :}
              | PRIM_TYPE:pt ARR_DIM:d                              {: RESULT = new Type(pt, d); :}
              ;

ARR_DIM     ::= L_BOX R_BOX ARR_DIM:d                               {: d.addNewDimension(); RESULT = d; :}                         
              | L_BOX R_BOX                                         {: RESULT = new ArrayDimensions(); :}
              ;

ARR_INDEX   ::= L_BOX EXPR:e R_BOX ARR_INDEX:l                      {: l.addIndex(e); RESULT = l; :}                          
              | L_BOX EXPR:e R_BOX                                  {: RESULT = new ArrayIndexes(e); :}
              ;

SUBPRG_DECL ::= FUNC_DECL:f                                         {: RESULT = f; :}
              | PROC_DECL:p                                         {: RESULT = p; :}
              ;

FUNC_DECL   ::= FUNCTION IDENT:i TYPE:t L_PAR ARG_LIST:al R_PAR 
                L_BRK STMT_LIST:sl RETURN_STMT:r R_BRK              {: RESULT = new FunctionDeclaration(i, t, al, sl, r); :}
              ;

RETURN_STMT ::= RETURN EXPR:e EOL                                   {: RESULT = new Return(e); :}
              ;

PROC_DECL   ::= PROCEDURE IDENT:i L_PAR ARG_LIST:al R_PAR 
                L_BRK STMT_LIST:sl R_BRK                            {: RESULT = new ProcedureDeclaration(i, al, sl); :}
              ;

MAIN_DECL   ::= MAIN L_PAR ARG_LIST:a R_PAR L_BRK STMT_LIST:s R_BRK {: RESULT = new MainDeclaration(a, s); :}
              ;

ARG         ::= TYPE:t IDENT:i                                      {: RESULT = new Argument(t, i); :}
              ;

ARG_LIST    ::= ARG:a ARG_TAIL:t                                    {: RESULT = new SymbolList<>(t, a); :}                                        
              |                                                     {: RESULT = new SymbolList<>(); :}                                        
              ;

ARG_TAIL    ::= COMMA ARG:a ARG_TAIL:t                              {: RESULT = new SymbolList<>(t, a); :}                                  
              |                                                     {: RESULT = new SymbolList<>(); :}
              ;

STMT        ::= CVA_DECL:d                                          {: RESULT = new CVADeclarationStatement(d); :}
              | ASGN:a                                              {: RESULT = a; :}        
              | READ_STMT:r                                         {: RESULT = r; :}
              | PRINT_STMT:p                                        {: RESULT = p; :}
              | LOOP:l                                              {: RESULT = l; :}
              | IF_STMT:i                                           {: RESULT = i; :}
              | CALL:c                                              {: RESULT = new CallStatement(c); :}
              ;

STMT_LIST   ::= STMT:s STMT_LIST:l                                  {: RESULT = new SymbolList<>(l, s); :}                                      
              |                                                     {: RESULT = new SymbolList<>(); :}
              ;

ASGN        ::= IDENT:i EQUALS EXPR:e EOL                           {: RESULT = new Assignment(i, e); :} 
              | IDENT:i ARR_INDEX:arrin EQUALS EXPR:e EOL           {: RESULT = new ArrayAssignment(i, arrin, e); :}
              ;

READ_STMT   ::= IDENT:i EQUALS READ EOL                             {: RESULT = new Read(i); :}
              ;

PRINT_STMT  ::= PRINT L_PAR EXPR:e R_PAR EOL                        {: RESULT = new Print(e); :}
              ;

LOOP        ::= WHILE L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l R_BRK    {: RESULT = new WhileLoop(c, l); :}
              ;

IF_STMT     ::= IF L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l R_BRK       {: RESULT = new If(c, l); :}
              | IF L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l1 R_BRK ELSE 
                L_BRK STMT_LIST:l2 R_BRK                            {: RESULT = new IfElse(c, l1, l2); :}
              ;

EXPR        ::= LIT
              | IDENT
              | IDENT ARR_INDEX
              | L_PAR EXPR R_PAR
              | CALL
              | SUB EXPR
              | EXPR ARITH_OP EXPR
              | EXPR REL:r EXPR
              | NOT EXPR
              | EXPR BIN_OP EXPR
              ;

EXPR_LIST   ::= EXPR COMMA EXPR_LIST
              |
              ;

LIT         ::= INT_LIT
              | BOOL_LIT
              | STR_LIT
              | ARR_LIT
              ;

LIT_LIST    ::= LIT LIT_TAIL
              |
              ;

LIT_TAIL    ::= COMMA LIT LIT_TAIL
              |
              ;

ARR_LIT     ::= L_BRK LIT_LIST R_BRK
              ;

CALL        ::= IDENT L_PAR EXPR_LIST R_PAR
             ;

ARITH_OP    ::= ADD
              | SUB
              | MUL
              | DIV
              | MOD
              ;

BIN_OP      ::= AND
              | OR
              ;
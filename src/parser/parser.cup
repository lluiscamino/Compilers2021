// Compile: java -jar libs/java-cup-11b.jar parser.cup

package parser;
import java.util.List;
import parser.symbols.*;
import parser.symbols.statements.*;
import parser.symbols.expressions.*;
import parser.symbols.expressions.literals.*;
import parser.symbols.statements.assignment.*;
import parser.symbols.statements.conditional.*;
import parser.symbols.statements.io.*;
import parser.symbols.statements.loop.*;

class Parser;

terminal                                CONST, VAR, ARRAY, FUNCTION, PROCEDURE, MAIN, RETURN, WHILE, IF, ELSE;
terminal                                L_PAR, R_PAR, L_BOX, R_BOX, L_BRK, R_BRK, COMMA, EOL;
terminal                                READ, PRINT;
terminal                                EQUALS;
terminal                                ADD, SUB, MUL, DIV, MOD;
terminal                                AND, OR, NOT;
terminal    RelationalOperatorType      REL;
terminal    String                      IDENT, PRIM_TYPE;

// Constants
terminal      Integer   INT_LIT;
terminal      Boolean   BOOL_LIT;
terminal      String    STR_LIT; 

non terminal  /*Program>*/                  PROGRAM;

// Declarations
non terminal  /*List<Declaration>*/         DECL_LIST;
non terminal  /*Declaration     */          DECL;
non terminal  /*CVADeclaration  */          CVA_DECL;
non terminal  /*PrimitiveDeclaration*/      PRIM_DECL;
non terminal  /*DeclarationMode*/           DECL_MODE;
non terminal  /*ArrayDeclaration*/          ARR_DECL;
non terminal  /*SubprogramDeclaration*/     SUBPRG_DECL;
non terminal  /*FunctionDeclaration*/       FUNC_DECL;
non terminal  /*ProcedureDeclaration*/      PROC_DECL;
non terminal  /*MainDeclaration*/           MAIN_DECL;

non terminal  /*Type*/                      TYPE;

non terminal                                ARG_TAIL;
non terminal  /*List<Argument>*/            ARG_LIST;
non terminal  /*Argument*/                  ARG;

non terminal  /*ArrayDimensions*/           ARR_DIM;
non terminal  ArrayIndexes                  ARR_INDEX;

// Statements
non terminal  List<Statement>               STMT_LIST;
non terminal  Statement                     STMT;
non terminal  Assignment                    ASGN;
non terminal  Read                          READ_STMT;
non terminal  Print                         PRINT_STMT;
non terminal  Loop                          LOOP;
non terminal  If                            IF_STMT;
non terminal  Call                          CALL;
non terminal  /*Return*/                    RETURN_STMT;

// Expressions
non terminal  List<Expression>              EXPR_LIST;
non terminal  Expression                    EXPR;
non terminal                                LIT_TAIL;
non terminal  List<Literal>                 LIT_LIST;
non terminal  Literal                       LIT;
non terminal  /*ArrayLiteral*/              ARR_LIT;

// Operators
non terminal  /*ArithmeticOperator*/        ARITH_OP;
non terminal  /*BinaryOperator*/            BIN_OP;

precedence left                             OR;
precedence left                             AND;
precedence left                             REL;
precedence left                             ADD, SUB;
precedence left                             MUL, DIV, MOD;

start with PROGRAM;

PROGRAM     ::= DECL_LIST:l MAIN_DECL:m
              ;

DECL        ::= CVA_DECL
              | SUBPRG_DECL
              ;

DECL_LIST   ::= DECL:d DECL_LIST: l
              |
              ;

CVA_DECL    ::= PRIM_DECL
              | ARR_DECL
              ;

PRIM_DECL   ::= DECL_MODE PRIM_TYPE IDENT EOL
              ;

ARR_DECL    ::= DECL_MODE ARRAY TYPE IDENT EOL
              ;

DECL_MODE   ::= CONST
              | VAR
              ;

TYPE        ::= PRIM_TYPE
              | PRIM_TYPE ARR_DIM
              ;

ARR_DIM     ::= L_BOX R_BOX ARR_DIM
              | L_BOX R_BOX
              ;

ARR_INDEX   ::= L_BOX EXPR R_BOX ARR_INDEX
              | L_BOX EXPR R_BOX
              ;

SUBPRG_DECL ::= FUNC_DECL
              | PROC_DECL
              ;

FUNC_DECL   ::= FUNCTION IDENT TYPE L_PAR ARG_LIST R_PAR L_BRK STMT_LIST RETURN_STMT R_BRK
              ;

RETURN_STMT ::= RETURN EXPR EOL
              ;

PROC_DECL   ::= PROCEDURE IDENT L_PAR ARG_LIST R_PAR L_BRK STMT_LIST R_BRK
              ;

MAIN_DECL   ::= MAIN L_PAR ARG_LIST R_PAR L_BRK STMT_LIST R_BRK
              ;

ARG         ::= TYPE IDENT
              ;

ARG_LIST    ::= ARG ARG_TAIL
              | 
              ;

ARG_TAIL    ::= COMMA ARG ARG_TAIL
              |
              ;

STMT        ::= CVA_DECL:d                                          {: RESULT = new CVADeclarationStatement(d); :}
              | ASGN:a                                              {: RESULT = a; :}        
              | READ_STMT:r                                         {: RESULT = r; :}
              | PRINT_STMT:p                                        {: RESULT = p; :}
              | LOOP:l                                              {: RESULT = l; :}
              | IF_STMT:i                                           {: RESULT = i; :}
              | CALL:c                                              {: RESULT = new CallStatement(c); :}
              ;

STMT_LIST   ::= STMT STMT_LIST
              |
              ;

ASGN        ::= IDENT:i EQUALS EXPR:e EOL                           {: RESULT = new Assignment(i, e); :} 
              | IDENT:i ARR_INDEX:arrin EQUALS EXPR:e EOL           {: RESULT = new ArrayAssignment(i, arrin, e); :}
              ;

READ_STMT   ::= IDENT:i EQUALS READ EOL                             {: RESULT = new Read(i); :}
              ;

PRINT_STMT  ::= PRINT L_PAR EXPR:e R_PAR EOL                        {: RESULT = new Print(e); :}
              ;

LOOP        ::= WHILE L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l R_BRK    {: RESULT = new WhileLoop(c, l); :}
              ;

IF_STMT     ::= IF L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l R_BRK       {: RESULT = new If(c, l); :}
              | IF L_PAR EXPR:c R_PAR L_BRK STMT_LIST:l1 R_BRK ELSE 
                L_BRK STMT_LIST:l2 R_BRK                            {: RESULT = new IfElse(c, l1, l2); :}
              ;

EXPR        ::= LIT
              | IDENT
              | IDENT ARR_INDEX
              | L_PAR EXPR R_PAR
              | CALL
              | SUB EXPR
              | EXPR ARITH_OP EXPR
              | EXPR REL:r EXPR
              | NOT EXPR
              | EXPR BIN_OP EXPR
              ;

EXPR_LIST   ::= EXPR COMMA EXPR_LIST
              |
              ;

LIT         ::= INT_LIT
              | BOOL_LIT
              | STR_LIT
              | ARR_LIT
              ;

LIT_LIST    ::= LIT LIT_TAIL
              |
              ;

LIT_TAIL    ::= COMMA LIT LIT_TAIL
              |
              ;

ARR_LIT     ::= L_BRK LIT_LIST R_BRK
              ;

CALL        ::= IDENT L_PAR EXPR_LIST R_PAR
             ;

ARITH_OP    ::= ADD
              | SUB
              | MUL
              | DIV
              | MOD
              ;

BIN_OP      ::= AND
              | OR
              ;